# Uses random distributions to determine just how bad
# the humans did at generating pi.

from random_numbers import random, initialise_random
from numpy import array, sqrt, ndarray
import numpy as np
from calculate import cfs
from typing import Callable
from scipy.optimize import curve_fit
from scipy.special import factorial
from sympy import divisors, gcd



# Contains a distribution of data.
#   The function passed must return (y: float or similar) data given (x, *args).
class Distribution:
    def __init__(self, function: Callable, *args) -> None:
        self.function = function
        self.args = args

    
    # Generates the curve associated with this function
    def generate(self, num_range: range, *args) -> tuple:
        
        # Gets the x values
        self.x = [x for x in num_range]

        # Ensures the first hundred values are extra dense.
        # This way, it looks smoother
        if len(self.x) > 100:
            self.x = [i / 10 for i in range(self.x[0] * 10, self.x[100] * 10)] + self.x[100:]

        # If no args were supplied, use the args sent during initialisation
        if not args:
            args = self.args

        # Generate y data
        self.y = array([self.function(point, *args) for point in self.x])

        return self.x, self.y



# Contains a distribution generated by random trials.
#   The generator must return both (x: ndarray, y: ndarray) given (trials, args).
class RandomDistribution:
    def __init__(self, generator: Callable, trials: int, *args) -> None:
        self.generator = generator
        self.trials = trials
        self.args = args

        self.dists  = {}

        self.generate()

    # Generates the random distribution
    def generate(self) -> tuple[ndarray, ndarray]:
        self.x, self.y = self.generator(self.trials, *self.args)

        return self.x, self.y

    # Obtains the theoretical curve of a guess distribution    
    def get_curve(self, name: str, num_range: range) -> tuple[ndarray, ndarray]:
        return self.dists[name]['dist'].generate(num_range)


    # Adds a guess of the underlying distribution
    def guess(self, function: Callable, name: str, guesses: tuple | None = None) -> None:
        
        # Tries to fit the guess to the random distribution
        params, cov = curve_fit(function, self.x, self.y, p0 = guesses)
        
        # Calculates the uncertainty of each variable
        uncs = np.sqrt(np.diag(cov))
        
        # Adds the Distribution
        self.dists[name] = {
            'dist':     Distribution(function, *params),
            'params':   params,
            'cov':      cov,
            'uncs':     uncs
        }

# A random distribution specifically for calculating pi
class PiDistribution(RandomDistribution):
    def __init__(self, trials: int, *args) -> None:
        
        # We want a coprime distribution to transform into a guess for π 
        super().__init__(coprime, trials, *args)

    # Generates a random distribution to guess at π
    def generate(self) -> tuple[ndarray, ndarray]:
        super().generate()

        # Calculates π
        self.pi = sqrt(6 / (self.y[0] / self.trials))


    




# Generators

# Generic generator returns a histogram, given a specific generator.
#   The specific generator must return a list
def generic_generator(nums: int, max_num: int, specific_generator: Callable, *args) -> tuple[ndarray, ndarray]:
    initialise_random(None)

    # Generates the requisite amount of random numbers
    counts = {}
    for i in range(nums):

        # Generates items
        generated = specific_generator(max_num, *args)

        # Counts the generated items
        for num in generated:
            if num not in counts:
                counts[num] = 0
            counts[num] += 1
        
    
    # Sorts the dictionry to be in ascending order of x (aka key)
    counts = dict(sorted(counts.items()))
    
    # Return a list of the number versus its count
    return array(list(counts.keys())), array(list(counts.values()))


# The distribution that is the factors of n
def factors(nums: int, max_num: int) -> tuple[ndarray, ndarray]:
    return generic_generator(
        nums = nums,
        max_num = max_num, 
        specific_generator = lambda max_nums: 
            divisors(random(end = max_nums)),
    )

# The distribution that is the common factors of n and m
def common_factors(pairs: int, max_num: int) -> tuple[ndarray, ndarray]:
    return generic_generator(
        nums = pairs,
        max_num = max_num, 
        specific_generator = lambda max_num: 
            cfs(random(end = max_num), random(end = max_num)),
    )

# The distribution that is the greatest common denominator of n and m
def greatest_common_denominator(pairs: int, max_num: int) -> tuple[ndarray, ndarray]:
    return generic_generator(
        nums = pairs,
        max_num = max_num,
        specific_generator = lambda max_num:
            [gcd(random(end = max_num), random(end = max_num))],
    )

# Gets the count of gcd's that equal n
def gcd_is_n(pairs: int, max_num: int, n: int) -> tuple[ndarray, ndarray]:
    return generic_generator(
        pairs,
        max_num,
        gcd_specific,
        n
    )

# Gets the count of gcd's that equal to 1, e.i. they are coprime
def coprime(pairs: int, max_num: int) -> tuple[ndarray, ndarray]:
    return generic_generator(
        pairs,
        max_num,
        lambda max_num: 
            {1: 1} if gcd(random(end = max_num), random(end = max_num)) == 1 else {}
    )

# This is too complicated to fit into a lambda, to here's
# the specific generator for gcd_is_n
def gcd_specific(max_num: int, n: int) -> dict[int]:
    a, b = random(end = max_num), random(end = max_num)
    d = gcd(a, b)
    return {d: 1} if d == n else {}


# Distribution generators.
#   In other words, distributions of distributions.

# Returns a generator to create gcd_is_n RandomDistributions
def dist_dist_gcd_is_n(trials: int, max_num: int, length: int, n: int) -> tuple[ndarray, tuple]:
    return generic_generator(
        trials,
        max_num,
        lambda max_num, length, n:
            RandomDistribution(gcd_is_n, length, max_num, n).y,
        length,
        n
    )

def dist_pi(trials: int, max_num: int, length: int) -> tuple[ndarray, tuple]:
    return generic_generator(
        trials,
        max_num,
        lambda max_num, length:
            [PiDistribution(length, max_num).pi],
        length
    )



# Guess distributions
def inverse(x, a, b, c):
    return a / (x - c) + b

def simple_inverse(x, a):
    return a / x

def poisson(x, l, a):
    return a * ((l ** x) * (np.e ** -l)) / factorial(x)

def inverse_log(x, a, b, c):
    return a / np.log(x + b) + c