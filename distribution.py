# Uses random distributions to determine just how bad
# the humans did at generating pi.

from random_numbers import random, initialise_random
from numpy import array, histogram, sqrt, pi, ndarray
from calculate import is_coprime
from logger import logger
from typing import Callable


# Contains a distribution of data.
#   The function passed must return (y: float or similar) data given (x, *args)
class Distribution:
    def __init__(self, function: Callable, *args) -> None:
        self.function = function
        self.args = args

    
    def generate(self, num_range: range) -> tuple:
        self.x = array([point for point in num_range])
        self.y = array([self.function(point, *self.args) for point in self.x])

        return self.x, self.y

# Contains a distribution generated by random trials.
#   The generator must return both (x: ndarray, y: ndarray) given (trials, args)
class RandomDistribution(Distribution):
    def __init__(self, function: Callable, generator: Callable, trials: int, *args) -> None:
        super().__init__(function, *args)
        self.generator = generator
        self.trials = trials

    def generate(self) -> tuple:
        self.x, self.y = self.generator(self.trials, self.args)

        return self.x, self.y


    
# Runs much faster than regular distribution, but less useful.
#   Used for generating histogram.
class SmallDistribution:
    def __init__(self, trials: int, length: int, max_num = 1e5) -> None:
        self.trials = trials
        self.length = length

        self.distribution = self.generate()

    # Generates a bunch of distributions
    def generate(self):

        # Sets the seed using system time
        initialise_random(None)

        dist = []
        for i in range(self.trials):
            
            # Gets the data for a single distribution.
            # We only care about the coprimes, for performance reasons
            coprimes = sum([
                is_coprime(
                    [random(end=1e5), random(end=1e5)] # Pairs of random numbers!
                ) for j in range(self.length)
            ])

            dist.append(coprimes)


        # Calculates Ï€
        pis = sqrt(6 / array(dist) * self.length)

        return pis
    
    # Creates a numpy histogram of the distribution data
    def histogram(self, bin_size: float = None) -> tuple[ndarray, ndarray, float]:

        if not bin_size:
            bin_size = 1 / sqrt(self.length)


        # Gets a bunch of reasonably sized bins
        bins = [pi + bin_size * (i - 0.5) for i in range(-30, 30)]

        y, x = histogram(self.distribution, bins)

        logger.log('dist print', [str(datum) for datum in x] + ['\n\n'] + [str(datum) for datum in y])

        # Grabs the histogram, trimming of excess zeroes
        x, y = self.trim_histogram(y, x)

        x += bin_size / 2

        return x, y, bin_size


    # Removes excess zereos.
    #   NOTE: the order is (y, x), the return order for np.histogram()
    def trim_histogram(self, y: ndarray, x: ndarray) -> tuple[ndarray]:
        
        # Finds the last leading zero
        start = 0
        for i in range(len(y)):
            if y[i] != 0:
                start = i
                break
        
        # Finds the first trailing zero
        stop = 0
        for i in range(len(y) - 1, 0, -1):
            if y[i] != 0:
                stop = i + 1
                break

        print(f'Slicing!:\t{start} : {stop}')

                
        # Trims and returns the arrays
        return x[start : stop], y[start : stop]

        
        