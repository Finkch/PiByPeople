# Uses random distributions to determine just how bad
# the humans did at generating pi.

from numpy import array, sqrt, ndarray
import numpy as np
from typing import Callable
from scipy.optimize import curve_fit
from scipy.special import factorial



# Contains a distribution of data.
#   The function passed must return (y: float or similar) data given (x, *args).
class Distribution:
    def __init__(self, function: Callable, *args) -> None:
        self.function = function
        self.args = args

    
    # Generates the curve associated with this function
    def generate(self, num_range: range, *args) -> tuple:
        
        # Gets the x values
        self.x = [x for x in num_range]

        # Ensures the first hundred values are extra dense.
        # This way, it looks smoother
        if len(self.x) > 100:
            self.x = [i / 10 for i in range(self.x[0] * 10, self.x[100] * 10)] + self.x[100:]

        # If no args were supplied, use the args sent during initialisation
        if not args:
            args = self.args

        # Generate y data
        self.y = array([self.function(point, *args) for point in self.x])

        return self.x, self.y



# Contains a distribution generated by random trials.
#   The generator must return both (x: ndarray, y: ndarray) given (trials, args).
class RandomDistribution:
    def __init__(self, generator: Callable, trials: int, *args) -> None:
        self.generator = generator
        self.trials = trials
        self.args = args

        self.dists  = {}

        self.generate()

    # Generates the random distribution
    def generate(self) -> tuple[ndarray, ndarray]:
        self.x, self.y = self.generator(self.trials, *self.args)

        return self.x, self.y

    # Obtains the theoretical curve of a guess distribution    
    def get_curve(self, name: str, num_range: range) -> tuple[ndarray, ndarray]:
        return self.dists[name]['dist'].generate(num_range)


    # Adds a guess of the underlying distribution
    def guess(self, function: Callable, name: str, guesses: tuple | None = None) -> None:
        
        # Tries to fit the guess to the random distribution
        params, cov = curve_fit(function, self.x, self.y, p0 = guesses)
        
        # Calculates the uncertainty of each variable
        uncs = np.sqrt(np.diag(cov))
        
        # Adds the Distribution
        self.dists[name] = {
            'dist':     Distribution(function, *params),
            'params':   params,
            'cov':      cov,
            'uncs':     uncs
        }

# A random distribution specifically for calculating pi.
#   `generator` should be coprime, but that can't be enforce
#   due to circular imports.
class PiDistribution(RandomDistribution):
    def __init__(self, generator: Callable, trials: int, *args) -> None:
        
        # We want a coprime distribution to transform into a guess for π 
        super().__init__(generator, trials, *args)

    # Generates a random distribution to guess at π
    def generate(self) -> tuple[ndarray, ndarray]:
        super().generate()

        # Calculates π
        self.pi = sqrt(6 / (self.y[0] / self.trials))


    



# Guess distributions
def inverse(x, a, b, c):
    return a / (x - c) + b

def simple_inverse(x, a):
    return a / x

def poisson(x, l, a):
    return a * ((l ** x) * (np.e ** -l)) / factorial(x)

def inverse_log(x, a, b, c):
    return a / np.log(x + b) + c